# Fastfile for Flutter iOS CI/CD

org, repo = (ENV["GITHUB_REPOSITORY"]||"").split("/")
match_org, match_repo = (ENV["MATCH_REPOSITORY"]||"").split("/")

platform :ios do

  def resolve_bundle_id(xcodeproj_path:, target_name:, configuration: "Release")
    require "xcodeproj"

    project_root = File.expand_path("..", __dir__)
    project_path = File.expand_path(xcodeproj_path, project_root)
    UI.user_error!("Xcode project not found at #{project_path}") unless File.exist?(project_path)
    project = Xcodeproj::Project.open(project_path)
    target = project.targets.find { |t| t.name == target_name }

    project_bundle_id = nil
    if target
      config = target.build_configurations.find { |c| c.name == configuration }
      project_bundle_id = config.build_settings["PRODUCT_BUNDLE_IDENTIFIER"] if config
    end

    env_bundle_id = ENV["IOS_BUNDLE_ID"]

    return project_bundle_id if env_bundle_id.nil? || env_bundle_id.empty?
    return env_bundle_id if ENV["IOS_BUNDLE_ID_FORCE"] == "true"

    if project_bundle_id && env_bundle_id != project_bundle_id
      UI.message("IOS_BUNDLE_ID=#{env_bundle_id} does not match Xcode project bundle id #{project_bundle_id}. Using project value.")
      return project_bundle_id
    end

    env_bundle_id
  end

  def profile_uuid_from_path(profile_path)
    require "open3"
    require "plist"

    stdout, stderr, status = Open3.capture3("/usr/bin/security", "cms", "-D", "-i", profile_path)
    if status.success?
      parsed = Plist.parse_xml(stdout)
      return parsed["UUID"] if parsed
    else
      UI.message("Failed to read provisioning profile UUID: #{stderr}")
    end

    nil
  end

  def install_profile_for_bundle(bundle_id)
    require "fileutils"

    profile_path = ENV["sigh_#{bundle_id}_appstore_profile-path"]
    return if profile_path.nil? || profile_path.empty?

    if File.exist?(profile_path)
      install_provisioning_profile(path: profile_path)
      profile_uuid = ENV["sigh_#{bundle_id}_appstore_profile-uuid"]
      profile_uuid = profile_uuid_from_path(profile_path) if profile_uuid.nil? || profile_uuid.empty?
      mobile_device_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
      FileUtils.mkdir_p(mobile_device_dir)

      if profile_uuid && !profile_uuid.empty?
        target_path = File.join(mobile_device_dir, "#{profile_uuid}.mobileprovision")
        FileUtils.cp(profile_path, target_path)
      else
        UI.message("Provisioning profile UUID missing; unable to copy to MobileDevice directory")
      end
    else
      UI.message("Provisioning profile not found at #{profile_path}, skipping install")
    end
  end

  def resolve_profile_uuid(bundle_id)
    uuid = ENV["sigh_#{bundle_id}_appstore_profile-uuid"]
    return uuid if uuid && !uuid.empty?

    profile_path = ENV["sigh_#{bundle_id}_appstore_profile-path"]
    return nil if profile_path.nil? || profile_path.empty? || !File.exist?(profile_path)

    profile_uuid_from_path(profile_path)
  end

  def apply_runner_signing_settings(project_path:, bundle_id:, team_id:, profile_name:, profile_uuid: nil)
    require "xcodeproj"

    project = Xcodeproj::Project.open(project_path)
    runner_target = project.targets.find { |t| t.name == "Runner" }
    UI.user_error!("Runner target not found in #{project_path}") unless runner_target

    runner_target.build_configurations.each do |config|
      next unless ["Release", "Profile", "Debug"].include?(config.name)

      settings = config.build_settings
      settings["CODE_SIGN_STYLE"] = "Manual"
      settings["DEVELOPMENT_TEAM"] = team_id if team_id && !team_id.empty?
      settings["CODE_SIGN_IDENTITY"] = "Apple Distribution"
      settings["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id if bundle_id && !bundle_id.empty?
      settings["PROVISIONING_PROFILE_SPECIFIER"] = profile_name if profile_name && !profile_name.empty?

      if profile_uuid && !profile_uuid.empty?
        settings["PROVISIONING_PROFILE"] = profile_uuid
        settings["PROVISIONING_PROFILE_SPECIFIER"] = ""
      end
    end

    project.save
  end

  lane :init_ci do
    github_action(
      api_token: ENV["GH_PAT"],
      org: org,
      repo: repo,
      match_org: match_org,
      match_repo: match_repo,
      writable_deploy_key: true
    )
  end
  
  desc "Sync codesigning certificates"
  lane :sync_certificates do
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_content: ENV['APPSTORE_P8']
    )

    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    notification_bundle_id = ENV["IOS_NOTIFICATIONS_BUNDLE_ID"]

    app_identifiers = [main_app_bundle_id].compact
    app_identifiers << notification_bundle_id if notification_bundle_id && !notification_bundle_id.empty?

    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: app_identifiers,
      api_key: api_key
    )

    install_profile_for_bundle(main_app_bundle_id)
  end

  desc "Sync codesigning certificates for Build"
  lane :sync_certificates_for_build do
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    notification_bundle_id = ENV["IOS_NOTIFICATIONS_BUNDLE_ID"]

    app_identifiers = [main_app_bundle_id].compact
    app_identifiers << notification_bundle_id if notification_bundle_id && !notification_bundle_id.empty?

    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: app_identifiers,
      readonly: false,
      api_key: api_key
    )

    install_profile_for_bundle(main_app_bundle_id)
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    setup_ci
    
    # Sync certificates
    sync_certificates
    
    # Configure manual code signing for Runner target only
    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    profile_mapping = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING] || {}
    main_profile = profile_mapping[main_app_bundle_id] || ENV["sigh_#{main_app_bundle_id}_appstore_profile-name"]
    UI.user_error!("No provisioning profile found for #{main_app_bundle_id}") if main_profile.nil? || main_profile.empty?

    install_profile_for_bundle(main_app_bundle_id)
    main_profile_uuid = resolve_profile_uuid(main_app_bundle_id)
    UI.user_error!("Provisioning profile UUID not found for #{main_app_bundle_id}") if main_profile_uuid.nil? || main_profile_uuid.empty?

    apply_runner_signing_settings(
      project_path: File.expand_path("../ios/Runner.xcodeproj", __dir__),
      bundle_id: main_app_bundle_id,
      team_id: ENV["APPLE_TEAM_ID"],
      profile_name: main_profile,
      profile_uuid: main_profile_uuid
    )
    
    # Update ExportOptions.plist with Match provisioning profiles
    export_options_path = File.expand_path("../ios/ExportOptions.plist", __dir__)
    
    # Get provisioning profile names from Match
    main_profile = profile_mapping[main_app_bundle_id] || ENV["sigh_#{main_app_bundle_id}_appstore_profile-name"]
    
    # Read, update and write ExportOptions.plist
    require 'plist'
    export_options = Plist.parse_xml(export_options_path)

    # If the ExportOptions.plist is missing or couldn't be parsed, create a minimal
    # export_options structure so we can populate teamID and provisioningProfiles.
    if export_options.nil?
      UI.message("ExportOptions.plist not found or invalid at #{export_options_path}. Creating a minimal ExportOptions structure.")
      export_options = {
        'method' => 'app-store',
        'teamID' => ENV['APPLE_TEAM_ID'],
        'provisioningProfiles' => {}
      }
    end

    # Ensure teamID is set when available
    export_options['teamID'] = ENV['APPLE_TEAM_ID'] if ENV['APPLE_TEAM_ID'] && !ENV['APPLE_TEAM_ID'].empty?

    # Populate provisioningProfiles mapping
    export_options['provisioningProfiles'] = {
      main_app_bundle_id => main_profile
    }

    export_options['signingStyle'] = 'manual'

    File.write(export_options_path, export_options.to_plist)
    
    # Determine a safe build number.
    # Default behavior: use an epoch timestamp to guarantee uniqueness between uploads.
    # If you *really* want to use the CI-provided BUILD_NUMBER (e.g. github.run_number),
    # set ENV['FORCE_CI_BUILD_NUMBER']='true' in the workflow.
    build_number_env = ENV['BUILD_NUMBER']
    if ENV['FORCE_CI_BUILD_NUMBER'] == 'true' && build_number_env && build_number_env.to_i > 0
      safe_build_number = build_number_env
      UI.message("Using CI-provided BUILD_NUMBER: #{safe_build_number} (FORCE_CI_BUILD_NUMBER=true)")
    else
      safe_build_number = Time.now.to_i.to_s
      if build_number_env && build_number_env.to_i > 0
        UI.message("Ignoring CI BUILD_NUMBER=#{build_number_env} in favor of timestamp to avoid duplicate uploads. To force CI BUILD_NUMBER set FORCE_CI_BUILD_NUMBER=true")
      end
      UI.message("Using timestamp build number: #{safe_build_number}")
    end

    # Build Flutter IPA with the chosen build number
    # Ensure iOS Info.plist CFBundleVersion is updated so App Store sees the new build number
    begin
      info_plist_path = File.expand_path("../ios/Runner/Info.plist", __dir__)
      if File.exist?(info_plist_path)
        UI.message("Updating #{info_plist_path} CFBundleVersion => #{safe_build_number}")
        require 'plist'
        info_plist = Plist.parse_xml(info_plist_path)
        info_plist['CFBundleVersion'] = safe_build_number
        File.write(info_plist_path, info_plist.to_plist)
      else
        UI.message("Warning: Info.plist not found at #{info_plist_path}, skipping CFBundleVersion update")
      end
    rescue => ex
      UI.message("Failed to update Info.plist: #{ex.message}")
    end

    # Build Flutter artifacts without signing, then archive/export via gym to control signing
    sh("flutter build ios --release --no-codesign --build-number=#{safe_build_number} --no-tree-shake-icons")

    build_app(
      workspace: "ios/Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      export_options: export_options,
      output_directory: File.expand_path("../build/ios/ipa", __dir__)
    )
    
    # Find the built IPA file with absolute path
    ipa_path = Dir.glob(File.expand_path("../build/ios/ipa/*.ipa", __dir__)).first
    UI.user_error!("No IPA file found at build/ios/ipa/") unless ipa_path
    
    # API Key for TestFlight upload
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      ipa: ipa_path,
      api_key: api_key
    )
  end

end
