# Fastfile for Flutter iOS CI/CD

org, repo = (ENV["GITHUB_REPOSITORY"]||"").split("/")
match_org, match_repo = (ENV["MATCH_REPOSITORY"]||"").split("/")

platform :ios do

  def resolve_bundle_id(xcodeproj_path:, target_name:, configuration: "Release")
    require "xcodeproj"

    project_root = File.expand_path("..", __dir__)
    project_path = File.expand_path(xcodeproj_path, project_root)
    UI.user_error!("Xcode project not found at #{project_path}") unless File.exist?(project_path)
    project = Xcodeproj::Project.open(project_path)
    target = project.targets.find { |t| t.name == target_name }

    project_bundle_id = nil
    if target
      config = target.build_configurations.find { |c| c.name == configuration }
      project_bundle_id = config.build_settings["PRODUCT_BUNDLE_IDENTIFIER"] if config
    end

    env_bundle_id = ENV["IOS_BUNDLE_ID"]

    return project_bundle_id if env_bundle_id.nil? || env_bundle_id.empty?
    return env_bundle_id if ENV["IOS_BUNDLE_ID_FORCE"] == "true"

    if project_bundle_id && env_bundle_id != project_bundle_id
      UI.message("IOS_BUNDLE_ID=#{env_bundle_id} does not match Xcode project bundle id #{project_bundle_id}. Using project value.")
      return project_bundle_id
    end

    env_bundle_id
  end

  def install_profile_for_bundle(bundle_id)
    profile_path = ENV["sigh_#{bundle_id}_appstore_profile-path"]
    return if profile_path.nil? || profile_path.empty?

    if File.exist?(profile_path)
      install_provisioning_profile(path: profile_path)
    else
      UI.message("Provisioning profile not found at #{profile_path}, skipping install")
    end
  end
  
  lane :init_ci do
    github_action(
      api_token: ENV["GH_PAT"],
      org: org,
      repo: repo,
      match_org: match_org,
      match_repo: match_repo,
      writable_deploy_key: true
    )
  end
  
  desc "Sync codesigning certificates"
  lane :sync_certificates do
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_content: ENV['APPSTORE_P8']

    )

    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    notification_bundle_id = ENV["IOS_NOTIFICATIONS_BUNDLE_ID"]

    app_identifiers = [main_app_bundle_id].compact
    app_identifiers << notification_bundle_id if notification_bundle_id && !notification_bundle_id.empty?

    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: app_identifiers,
      api_key: api_key
    )

    install_profile_for_bundle(main_app_bundle_id)
  end

desc "Sync codesigning certificates for Build"
  lane :sync_certificates_for_build do
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    notification_bundle_id = ENV["IOS_NOTIFICATIONS_BUNDLE_ID"]

    app_identifiers = [main_app_bundle_id].compact
    app_identifiers << notification_bundle_id if notification_bundle_id && !notification_bundle_id.empty?

    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: app_identifiers,
      readonly: false,
      api_key: api_key
    )

    install_profile_for_bundle(main_app_bundle_id)
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    setup_ci
    
    # Sync certificates
    sync_certificates
    
    # Configure manual code signing for Xcode project
    main_app_bundle_id = resolve_bundle_id(
      xcodeproj_path: "ios/Runner.xcodeproj",
      target_name: "Runner"
    )
    UI.user_error!("Failed to resolve main app bundle id") if main_app_bundle_id.nil? || main_app_bundle_id.empty?

    profile_mapping = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING] || {}
    main_profile = profile_mapping[main_app_bundle_id] || ENV["sigh_#{main_app_bundle_id}_appstore_profile-name"]
    UI.user_error!("No provisioning profile found for #{main_app_bundle_id}") if main_profile.nil? || main_profile.empty?

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "ios/Runner.xcodeproj",
      targets: "Runner",
      team_id: ENV["APPLE_TEAM_ID"],
      bundle_identifier: main_app_bundle_id,
      profile_name: main_profile,
      code_sign_identity: "Apple Distribution"
    )

    install_profile_for_bundle(main_app_bundle_id)
    
    # Update ExportOptions.plist with Match provisioning profiles
    export_options_path = File.expand_path("../ios/ExportOptions.plist", __dir__)
    
    # Get provisioning profile names from Match
    profile_mapping = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING] || {}
    main_profile = profile_mapping[main_app_bundle_id] || ENV["sigh_#{main_app_bundle_id}_appstore_profile-name"]
    UI.user_error!("No provisioning profile found for #{main_app_bundle_id}") if main_profile.nil? || main_profile.empty?
    
    # Read, update and write ExportOptions.plist
    require 'plist'
    export_options = Plist.parse_xml(export_options_path)

    # If the ExportOptions.plist is missing or couldn't be parsed, create a minimal
    # export_options structure so we can populate teamID and provisioningProfiles.
    if export_options.nil?
      UI.message("ExportOptions.plist not found or invalid at #{export_options_path}. Creating a minimal ExportOptions structure.")
      export_options = {
        'method' => 'app-store',
        'teamID' => ENV['APPLE_TEAM_ID'],
        'provisioningProfiles' => {}
      }
    end

    # Ensure teamID is set when available
    export_options['teamID'] = ENV['APPLE_TEAM_ID'] if ENV['APPLE_TEAM_ID'] && !ENV['APPLE_TEAM_ID'].empty?

    # Populate provisioningProfiles mapping
    export_options['provisioningProfiles'] = {
      main_app_bundle_id => main_profile
    }

    export_options['signingStyle'] = 'manual'

    File.write(export_options_path, export_options.to_plist)
    
    # Determine a safe build number.
    # Default behavior: use an epoch timestamp to guarantee uniqueness between uploads.
    # If you *really* want to use the CI-provided BUILD_NUMBER (e.g. github.run_number),
    # set ENV['FORCE_CI_BUILD_NUMBER']='true' in the workflow.
    build_number_env = ENV['BUILD_NUMBER']
    if ENV['FORCE_CI_BUILD_NUMBER'] == 'true' && build_number_env && build_number_env.to_i > 0
      safe_build_number = build_number_env
      UI.message("Using CI-provided BUILD_NUMBER: #{safe_build_number} (FORCE_CI_BUILD_NUMBER=true)")
    else
      safe_build_number = Time.now.to_i.to_s
      if build_number_env && build_number_env.to_i > 0
        UI.message("Ignoring CI BUILD_NUMBER=#{build_number_env} in favor of timestamp to avoid duplicate uploads. To force CI BUILD_NUMBER set FORCE_CI_BUILD_NUMBER=true")
      end
      UI.message("Using timestamp build number: #{safe_build_number}")
    end

    # Build Flutter IPA with the chosen build number
    # Ensure iOS Info.plist CFBundleVersion is updated so App Store sees the new build number
    begin
      info_plist_path = File.expand_path("../ios/Runner/Info.plist", __dir__)
      if File.exist?(info_plist_path)
        UI.message("Updating #{info_plist_path} CFBundleVersion => #{safe_build_number}")
        require 'plist'
        info_plist = Plist.parse_xml(info_plist_path)
        info_plist['CFBundleVersion'] = safe_build_number
        File.write(info_plist_path, info_plist.to_plist)
      else
        UI.message("Warning: Info.plist not found at #{info_plist_path}, skipping CFBundleVersion update")
      end
    rescue => ex
      UI.message("Failed to update Info.plist: #{ex.message}")
    end

    sh("flutter build ipa --release --export-options-plist=#{export_options_path} --build-number=#{safe_build_number} --no-tree-shake-icons")
    
    # Find the built IPA file with absolute path
    ipa_path = Dir.glob(File.expand_path("../build/ios/ipa/*.ipa", __dir__)).first
    UI.user_error!("No IPA file found at build/ios/ipa/") unless ipa_path
    
    # API Key for TestFlight upload
    api_key = app_store_connect_api_key(
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      ipa: ipa_path,
      api_key: api_key
    )
  end

end
